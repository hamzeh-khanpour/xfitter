#!/usr/bin/env python
print "This code-generating script was written for an older version and is currently broken and needs to be rewritten.\nSorry!"
exit(-1)

''' Script to generate templates for new PDF parameterisation '''

import sys
import os
import datetime

if len(sys.argv)<2:
  print "Usage: "+__file__+" NAME\n Expects working directory to be xFitter root directory"
  exit(1)
# Are we in the correct directory?
if not os.path.isdir("pdfparams"):
  print "pdfparams directory not found"
  exit(2)
# First check if the name is already used
name=sys.argv[1]
prefix="pdfparams/"+name
if os.path.isdir(prefix):
  print prefix+" already exists"
  exit(3)
classname=None
if name[-1].isupper():
  classname=name+"_PdfParam"
else:
  classname=name+"PdfParam"

print "Creating directories in "+prefix
os.makedirs(prefix+"/include")
os.makedirs(prefix+"/src")
#here this script used to create an empty prefix+"/yaml/parameters.yaml", but I do not see why --Ivan

formatDict={"name":name,"classname":classname,"date":datetime.date.today().isoformat(),"scriptname":__file__}

hFile=prefix+"/include/"+classname+".h"
print "Creating header file "+hFile

with open(hFile,"w") as f:
  f.write('''//Automatically generated by {scriptname} on {date}
#pragma once
#include"BasePdfParam.h"

/**
  @class {classname}

  @brief A class for {name} pdf parameterisation

  ADD DESCRIPTION HERE

*/

namespace xfitter{{
class {classname}:public BasePdfParam{{
  public:
    {classname}(const std::string&name):BasePdfParam(name){{}}
    virtual double operator()(double x)const override final;
    // virtual double  moment(int nMoment=-1)const override final;
    // virtual void setMoment(int nMoment,double value)override final;
    // virtual void atStart()override final;
}};
}}
'''.format(**formatDict)
)

sFile=prefix+"/src/"+classname+".cc"
print "Creating source file "+sFile

with open(sFile,"w") as f:
  f.write('''//Automatically generated by {scriptname} on {date}

#include"{classname}.h"
//These might be useful
//#include"xfitter_cpp_base.h" //for hf_errlog
//#include<cmath>
//#include<iostream>

namespace xfitter{{
//for dynamic loading
extern"C" {classname}*create(const char*s){{return new {classname}(s);}}

double {classname}::operator()(double x)const{{
  //Your code here
}}

//OPTIONAL

//void {classname}::atStart(){{
//  Your code here
//  Check that number of parameters is sane
//}}
//double {classname}::moment(int n)const{{
//  Your code here
//}}
//void {classname}::setMoment(int n,double val){{
//  Your code here
//}}
}}
'''.format(**formatDict)
)

aFile=prefix+"/src/Makefile.am"
print "Creating automake file "+aFile

with open(aFile,"w") as f:
  f.write('''#Automatically generated by {scriptname} on {date}
AM_CXXFLAGS=-I$(srcdir)/../include -I$(srcdir)/../../../include -I$(srcdir)/../../BasePdfParam/include -Wall -fPIC -Wno-deprecated

lib_LTLIBRARIES=lib{classname}_xfitter.la
lib{classname}_xfitter_la_SOURCES={classname}.cc
dist_noinst_HEADERS=../include
lib{classname}_xfitter_la_LDFLAGS=-lBasePdfParam_xfitter -L$(libdir)
'''.format(**formatDict))

def insertLine(filename,after,line):
  after=after.replace('/',r'\/')
  if line[0]==' ':line='\\'+line
  s="sed -i '/{}/a{}' {}".format(after,line,filename)
  os.system(s)
print "Updating configure.ac"
insertLine("configure.ac","pdfparams/BasePdfParam/src/Makefile","                 {}/src/Makefile".format(prefix))
print "Updating Makefile.am"
insertLine("Makefile.am","pdfparams/BasePdfParam/src","  {}/src\\\\".format(prefix))
print "Updating doxygen.cfg"
insertLine("doxygen.cfg","pdfparams/BasePdfParam/include","                         {}/include\\\\".format(prefix))
print "Updating Reactions.txt"
insertLine("Reactions.txt","HERAPDF",name+" lib"+classname+"_xfitter.so")
